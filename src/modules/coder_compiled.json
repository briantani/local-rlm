{
  "generate_code.predict": {
    "traces": [],
    "train": [],
    "demos": [
      {
        "augmented": true,
        "task": "Count word frequencies in text",
        "context_summary": "",
        "reasoning": "To count word frequencies in a given text, we can use Python's built-in `collections.Counter` to facilitate this task. This approach is straightforward and efficient for counting occurrences of each word.",
        "python_code": "from collections import Counter\n\ntext = \"This is an example text with some words repeated and some not.\"\nwords = text.split()\nword_frequencies = Counter(words)\nprint(word_frequencies)"
      },
      {
        "augmented": true,
        "task": "Calculate compound interest",
        "context_summary": "",
        "reasoning": "To calculate compound interest, we can use the formula: A = P(1 + r/n)^(nt), where:\n- A is the amount of money accumulated after n years, including interest.\n- P is the principal amount (the initial amount of money).\n- r is the annual interest rate (decimal).\n- n is the number of times that interest is compounded per year.\n- t is the time the money is invested for in years.",
        "python_code": "# No imports needed\nprincipal = 1000  # Initial investment\nrate = 0.05       # Annual interest rate\nn = 4             # Compounded quarterly\ntime = 3          # Years\n\namount = principal * (1 + rate/n)**(n*time)\ninterest = amount - principal\n\nprint(f'Initial Principal: ${principal}')\nprint(f'Annual Interest Rate: {rate*100}%')\nprint(f'Compounding Frequency: {n} times per year')\nprint(f'Time Period: {time} years')\nprint(f'Amount after {time} years: ${amount:.2f}')\nprint(f'Compound Interest Earned: ${interest:.2f}')"
      },
      {
        "task": "Convert data to JSON and save it",
        "context_summary": "output_dir = '/tmp/output'",
        "python_code": "# json is pre-loaded - NO imports\ndata = {'name': 'Report', 'values': [1, 2, 3], 'meta': {'version': '1.0'}}\nwith open(f'{output_dir}/data.json', 'w') as f:\n    json.dump(data, f, indent=2)\nprint('JSON saved')\nprint(json.dumps(data, indent=2))"
      }
    ],
    "signature": {
      "instructions": "The task is to predict Python code based on a given task description and an optional context summary. The goal is to generate executable Python code that adheres to specific rules, such as no import statements or subprocess calls, and uses pre-loaded libraries like numpy, pandas, plt, sns, etc.\n\nTo achieve this, the following steps should be followed:\n\n1. **Parse Input**: Extract the task description and context summary from the inputs.\n2. **Reasoning**: Use a step-by-step reasoning process to break down the task into smaller, manageable steps.\n3. **Generate Code**: Based on the reasoning, generate Python code that solves the given task without importing any modules (all necessary functions are pre-loaded).\n4. **Formatting**: Ensure the generated code is formatted correctly, adhering to the rules provided (e.g., no subprocess calls, use of `plt.savefig()` instead of `plt.show()`).\n\n### Example:\nFor the task \"Calculate correlation between two variables,\" the reasoning might involve:\n- Identify that scipy_stats library has a function to calculate correlation.\n- Extract necessary data from a sample input or historical data.\n- Use `scipy_stats.pearsonr` to compute the correlation coefficient.\n\nThe Python code should be:\n```python\n# scipy_stats is pre-loaded - NO imports\ndata = np.random.randn(100, 2)\ncorrelation_coefficient, p_value = scipy_stats.pearsonr(data[:, 0], data[:, 1])\nprint(f'Pearson correlation coefficient: {correlation_coefficient}')\nprint(f'P-value: {p_value}')\n```\n\n### Steps:\n1. **Input Parsing**:\n   - `task`: \"Calculate correlation between two variables\"\n   - `context_summary` (if provided): Information about the previous steps or relevant context.\n\n2. **Reasoning**:\n   - Identify necessary libraries and functions.\n   - Extract data if available or simulate with a random dataset.\n\n3. **Code Generation**:\n   - Construct Python code using the pre-loaded library functions.\n   - Ensure no import statements are used.\n\n4. **Output**:\n   - The generated Python code should be printed directly to stdout.",
      "fields": [
        {
          "prefix": "Task:",
          "description": "The task to solve with Python code."
        },
        {
          "prefix": "Context Summary:",
          "description": "Execution history metadata."
        },
        {
          "prefix": "Reasoning: Let's think step by step in order to",
          "description": "${reasoning}"
        },
        {
          "prefix": "Python Code:",
          "description": "Executable Python code only. No markdown, no imports."
        }
      ]
    },
    "lm": null
  },
  "metadata": {
    "dependency_versions": {
      "python": "3.14",
      "dspy": "3.0.4",
      "cloudpickle": "3.1"
    }
  }
}
