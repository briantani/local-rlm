{% extends "base.html" %}

{% block title %}RLM Agent - Home{% endblock %}

{% block content %}
<div x-data="taskRunner()" x-init="init()" class="space-y-6">

    <!-- Task Input Card -->
    <div class="bg-white rounded-lg shadow p-6">
        <h2 class="text-lg font-semibold text-gray-900 mb-4">üéØ Run a Task</h2>

        <form @submit.prevent="submitTask" class="space-y-4">
            <!-- Config Selector -->
            <div>
                <label for="config" class="block text-sm font-medium text-gray-700 mb-2">
                    Configuration Profile
                </label>
                <select
                    id="config"
                    x-model="selectedConfig"
                    @change="onConfigChange"
                    class="w-full px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                    :disabled="isRunning"
                >
                    <option value="" x-show="configs.length === 0">Loading configs...</option>
                    <option value="" x-show="configs.length > 0" disabled>Select a configuration...</option>
                    <template x-for="config in configs" :key="config.name">
                        <option :value="config.name" x-text="`${config.name} - ${config.description}`"></option>
                    </template>
                </select>
                <p class="mt-1 text-sm text-gray-500" x-show="configDetails" x-cloak>
                    <span x-text="configDetails"></span>
                </p>
            </div>

            <!-- Template Selector (Optional) -->
            <div>
                <label for="template" class="block text-sm font-medium text-gray-700 mb-2">
                    Load from Template (Optional)
                    <span class="text-gray-500 text-xs">‚Äî Start with a saved configuration</span>
                </label>
                <div class="flex space-x-2">
                    <select
                        id="template"
                        x-model="selectedTemplate"
                        class="flex-1 px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        :disabled="isRunning"
                    >
                        <option value="">No template (manual entry)</option>
                        <template x-for="template in templates" :key="template.id">
                            <option :value="template.id" x-text="`${template.name} ‚Äî ${template.description}`"></option>
                        </template>
                    </select>
                    <button
                        type="button"
                        @click="applyTemplate"
                        class="px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700 disabled:bg-gray-400 transition"
                        :disabled="!selectedTemplate || isRunning"
                    >
                        Apply
                    </button>
                </div>
                <p class="mt-1 text-xs text-gray-500">
                    üìö Templates let you reuse successful task configurations. Save one from a completed task result!
                </p>
            </div>

            <!-- Task Input -->
            <div>
                <label for="task" class="block text-sm font-medium text-gray-700 mb-2">
                    Task Description
                </label>
                <textarea
                    id="task"
                    x-model="taskText"
                    rows="4"
                    class="w-full px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                    placeholder="e.g., Calculate the 100th fibonacci number"
                    :disabled="isRunning"
                ></textarea>
            </div>
            <!-- Context Path (Optional) -->
            <div>
                <label for="contextPath" class="block text-sm font-medium text-gray-700 mb-2">
                    Context Folder (Optional)
                    <span class="text-gray-500 text-xs">‚Äî Absolute path to folder with files the agent can access</span>
                </label>
                <div class="flex gap-2">
                    <input
                        id="contextPath"
                        x-model="contextPath"
                        type="text"
                        class="flex-1 px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        :placeholder="contextPathPlaceholder"
                        :disabled="isRunning"
                    />
                    <button
                        @click="selectFolder()"
                        type="button"
                        :disabled="isRunning"
                        class="px-4 py-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-md border border-gray-300 transition-colors disabled:opacity-50 disabled:cursor-not-allowed whitespace-nowrap"
                        title="Browse to find folder name, then enter full path"
                    >
                        üìÅ Browse
                    </button>
                </div>
                <div x-show="folderHint" x-transition class="mt-2 p-3 bg-blue-50 border border-blue-200 rounded-md">
                    <p class="text-sm text-blue-800" x-html="folderHint"></p>
                </div>
                <p class="mt-1 text-xs text-gray-500">
                    üí° Agent can read files using Python code (e.g., <code class="bg-gray-100 px-1 rounded">pd.read_csv('data.csv')</code>).
                    Folder contents will be listed at the start of execution.
                </p>
            </div>

            <!-- Submit Button -->
            <div class="flex items-center justify-between">
                <button
                    type="submit"
                    class="px-6 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition"
                    :disabled="!canSubmit"
                >
                    <span x-show="!isRunning" x-cloak>‚ñ∂Ô∏è Run Task</span>
                    <span x-show="isRunning" x-cloak>‚è≥ Running...</span>
                </button>

                <button
                    v-show="isRunning"
                    @click="stopTask"
                    type="button"
                    class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition"
                    x-show="isRunning"
                    x-cloak
                >
                    ‚èπÔ∏è Stop
                </button>
            </div>
        </form>
    </div>

    <!-- Execution Area -->
    <div x-show="taskId" x-cloak class="space-y-4">

        <!-- Steps Container -->
        <div class="bg-white rounded-lg shadow p-6">
            <h3 class="text-lg font-semibold text-gray-900 mb-4">
                üìã Execution Steps
            </h3>

            <div class="space-y-3">
                <template x-for="(step, index) in steps" :key="index">
                    <div class="border border-gray-200 rounded-lg p-4">
                        <!-- Step Header -->
                        <div class="flex items-center justify-between mb-2">
                            <span class="text-sm font-medium text-gray-700">
                                Step <span x-text="index + 1"></span>: <span x-text="step.action"></span>
                            </span>
                            <span
                                class="text-xs px-2 py-1 rounded"
                                :class="{
                                    'bg-blue-100 text-blue-800': step.status === 'running',
                                    'bg-green-100 text-green-800': step.status === 'complete',
                                    'bg-red-100 text-red-800': step.status === 'error'
                                }"
                                x-text="step.status"
                            ></span>
                        </div>

                        <!-- Code Block (if exists) -->
                        <div x-show="step.code" x-cloak class="mt-3">
                            <div class="text-xs text-gray-500 mb-1">Code:</div>
                            <pre class="bg-gray-900 text-gray-100 p-3 rounded text-sm overflow-x-auto"><code x-text="step.code"></code></pre>
                        </div>

                        <!-- Output Block (if exists) -->
                        <div x-show="step.output" x-cloak class="mt-3">
                            <div class="text-xs text-gray-500 mb-1">Output:</div>
                            <pre class="bg-gray-50 border border-gray-200 p-3 rounded text-sm overflow-x-auto"><code x-text="step.output"></code></pre>
                        </div>
                    </div>
                </template>

                <!-- Empty State -->
                <div x-show="steps.length === 0" x-cloak class="text-center py-8 text-gray-400">
                    Waiting for execution to start...
                </div>
            </div>
        </div>

        <!-- Final Result - Canvas View -->
        <div x-show="result" x-cloak>
            <div x-data="canvasViewer(result, taskId)">
                {% include 'components/canvas.html' %}
            </div>
        </div>

        <!-- Error Display -->
        <div x-show="error" x-cloak class="bg-red-50 border border-red-200 rounded-lg p-4">
            <h3 class="text-lg font-semibold text-red-900 mb-2">
                ‚ùå Error
            </h3>
            <p class="text-red-700" x-text="error"></p>
        </div>

        <!-- Chat Panel (appears after completion) -->
        <div x-show="result && currentTaskId" x-cloak :data-task-id="currentTaskId">
            {% include 'components/chat_panel.html' %}
        </div>
    </div>

</div>

<!-- API Key Modal Component -->
{% include 'components/api_key_modal.html' %}

{% endblock %}

{% block scripts %}
<script>
function taskRunner() {
    return {
        // Config state
        configs: [],
        selectedConfig: '',
        configDetails: '',
        requiredProviders: [],

        // Template state
        templates: [],
        selectedTemplate: '',

        // Task state
        taskText: '',
        contextPath: '',
        contextPathPlaceholder: '',
        folderHint: '',
        taskId: null,
        currentTaskId: null,  // For chat panel integration
        isRunning: false,

        async selectFolder() {
            try {
                const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
                const isWindows = navigator.platform.toUpperCase().indexOf('WIN') >= 0;

                // Try modern File System Access API first (Chrome/Edge)
                if ('showDirectoryPicker' in window) {
                    const dirHandle = await window.showDirectoryPicker({
                        mode: 'read',
                        startIn: 'downloads' // Defaults to downloads folder
                    });

                    const folderName = dirHandle.name;

                    // Provide OS-specific path hints
                    if (isMac) {
                        this.folderHint = `<strong>Selected:</strong> ${folderName}<br><strong>Common Mac paths:</strong><br>‚Ä¢ Downloads: <code>/Users/yourname/Downloads</code><br>‚Ä¢ Documents: <code>/Users/yourname/Documents</code><br>‚Ä¢ Desktop: <code>/Users/yourname/Desktop</code><br><em>Replace "yourname" with your username</em>`;
                        // Try to be helpful - if it's Downloads, suggest the path
                        if (folderName === 'Downloads') {
                            this.contextPath = '/Users/' + (process.env.USER || 'yourname') + '/Downloads';
                        }
                    } else if (isWindows) {
                        this.folderHint = `<strong>Selected:</strong> ${folderName}<br><strong>Common Windows paths:</strong><br>‚Ä¢ Downloads: <code>C:\\Users\\yourname\\Downloads</code><br>‚Ä¢ Documents: <code>C:\\Users\\yourname\\Documents</code><br>‚Ä¢ Desktop: <code>C:\\Users\\yourname\\Desktop</code><br><em>Replace "yourname" with your username</em>`;
                        if (folderName === 'Downloads') {
                            this.contextPath = 'C:\\Users\\yourname\\Downloads';
                        }
                    } else {
                        this.folderHint = `<strong>Selected:</strong> ${folderName}<br><strong>Linux path example:</strong> <code>/home/yourname/${folderName.toLowerCase()}</code>`;
                    }

                } else {
                    // Fallback: show file input dialog
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.webkitdirectory = true;
                    input.directory = true;

                    input.onchange = (e) => {
                        const files = e.target.files;
                        if (files && files.length > 0) {
                            const fullPath = files[0].webkitRelativePath || files[0].name;
                            const folderName = fullPath.split('/')[0];

                            if (isMac) {
                                this.folderHint = `<strong>Selected:</strong> ${folderName}<br><strong>Enter full Mac path above</strong>, e.g.: <code>/Users/yourname/${folderName}</code>`;
                            } else if (isWindows) {
                                this.folderHint = `<strong>Selected:</strong> ${folderName}<br><strong>Enter full Windows path above</strong>, e.g.: <code>C:\\Users\\yourname\\${folderName}</code>`;
                            } else {
                                this.folderHint = `<strong>Selected:</strong> ${folderName}<br><strong>Enter full path above</strong>, e.g.: <code>/home/yourname/${folderName.toLowerCase()}</code>`;
                            }
                        }
                    };

                    input.click();
                }
            } catch (err) {
                // User cancelled - don't show error
                if (err.name !== 'AbortError') {
                    console.error('Error selecting folder:', err);
                    this.folderHint = '<strong>Error:</strong> Could not access folder picker. Please enter the path manually.';
                }
            }
        },

        // Execution state
        steps: [],
        result: null,
        error: null,

        // WebSocket
        ws: null,

        async init() {
            // Detect OS for better path hints
            const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
            const isWindows = navigator.platform.toUpperCase().indexOf('WIN') >= 0;

            if (isMac) {
                this.contextPathPlaceholder = 'e.g., /Users/yourname/Downloads';
            } else if (isWindows) {
                this.contextPathPlaceholder = 'e.g., C:\\Users\\yourname\\Downloads';
            } else {
                this.contextPathPlaceholder = 'e.g., /home/yourname/downloads';
            }

            await this.loadConfigs();
            await this.loadTemplates();
        },

        async loadConfigs() {
            try {
                const response = await fetch('/api/configs');
                const data = await response.json();
                // Handle both array and {profiles: [...], count: ...} response formats
                const configsList = data.profiles || data;
                this.configs = configsList;

                // Check if there's a config in URL params
                const urlParams = new URLSearchParams(window.location.search);
                const configParam = urlParams.get('config');

                // Try to find local-only config as default
                const localOnlyConfig = configsList.find(c => c.name === 'local-only');

                // Select config: URL param > local-only > first in list
                if (configParam && configsList.some(c => c.name === configParam)) {
                    this.selectedConfig = configParam;
                    await this.onConfigChange();
                } else if (localOnlyConfig) {
                    this.selectedConfig = 'local-only';
                    await this.onConfigChange();
                } else if (configsList.length > 0) {
                    this.selectedConfig = configsList[0].name;
                    await this.onConfigChange();
                }
            } catch (e) {
                console.error('Failed to load configs:', e);
            }
        },

        async loadTemplates() {
            try {
                const response = await fetch('/api/templates');
                const data = await response.json();
                this.templates = data;
            } catch (e) {
                console.error('Failed to load templates:', e);
                this.templates = [];
            }
        },

        async applyTemplate() {
            if (!this.selectedTemplate) return;

            try {
                const response = await fetch(`/api/templates/${this.selectedTemplate}/apply`, {
                    method: 'POST'
                });

                if (!response.ok) throw new Error('Failed to apply template');

                const data = await response.json();

                // Apply template data to form
                this.taskText = data.task_text;
                this.contextPath = data.context_path || '';
                this.selectedConfig = data.config_name;

                // Update config details
                await this.onConfigChange();

                alert('Template applied successfully!');
            } catch (e) {
                console.error('Apply template failed:', e);
                alert('Failed to apply template: ' + e.message);
            }
        },

        async onConfigChange() {
            if (!this.selectedConfig) return;

            try {
                const response = await fetch(`/api/configs/${this.selectedConfig}`);
                const config = await response.json();

                this.configDetails = config.description;
                this.requiredProviders = config.required_providers || [];

                // Check if API keys are needed (but don't prompt on initial load for local-only)
                await this.checkApiKeys();
            } catch (e) {
                console.error('Failed to load config details:', e);
            }
        },

        async checkApiKeys() {
            const session = Alpine.store('sessionStore');
            await session.checkApiKeys();

            // Don't show modal for local-only config (no API keys needed)
            if (this.selectedConfig === 'local-only') {
                return;
            }

            // Check if required keys are missing
            const missingKeys = this.requiredProviders.filter(
                provider => !session.apiKeys[provider.toLowerCase()]
            );

            if (missingKeys.length > 0) {
                // Open modal to configure API keys
                this.$dispatch('open-api-key-modal', { providers: missingKeys });
            }
        },

        get canSubmit() {
            return this.taskText.trim() && this.selectedConfig && !this.isRunning;
        },

        async submitTask() {
            if (!this.canSubmit) return;

            const session = Alpine.store('sessionStore');

            // Reset state
            this.steps = [];
            this.result = null;
            this.error = null;
            this.isRunning = true;

            try {
                // Create task
                const requestBody = {
                    task: this.taskText,
                    config_name: this.selectedConfig
                };

                // Include context_path if provided
                if (this.contextPath.trim()) {
                    requestBody.context_path = this.contextPath.trim();
                }

                const response = await fetch('/api/tasks', {
                    method: 'POST',
                    headers: session.getHeaders(),
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Failed to create task');
                }

                const task = await response.json();
                this.taskId = task.task_id;
                this.currentTaskId = task.task_id;  // Set for chat panel

                // Connect to WebSocket for real-time updates
                this.connectWebSocket();

            } catch (e) {
                this.error = e.message;
                this.isRunning = false;
            }
        },

        connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/tasks/${this.taskId}`;

            this.ws = new WebSocket(wsUrl);

            this.ws.onmessage = (event) => {
                const update = JSON.parse(event.data);
                this.handleUpdate(update);
            };

            this.ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                this.error = 'Connection error occurred';
            };

            this.ws.onclose = () => {
                this.isRunning = false;
            };
        },

        handleUpdate(update) {
            switch (update.type) {
                case 'status':
                    // Status update
                    break;

                case 'step':
                    // New step started
                    this.steps.push({
                        action: update.data.action,
                        status: 'running',
                        code: null,
                        output: null
                    });
                    break;

                case 'code':
                    // Code generated
                    if (this.steps.length > 0) {
                        this.steps[this.steps.length - 1].code = update.data.code;
                    }
                    break;

                case 'output':
                    // Code execution output
                    if (this.steps.length > 0) {
                        this.steps[this.steps.length - 1].output = update.data.output;
                    }
                    break;

                case 'complete':
                    // Task completed
                    if (this.steps.length > 0) {
                        this.steps[this.steps.length - 1].status = 'complete';
                    }
                    this.result = update.data;
                    this.isRunning = false;
                    if (this.ws) {
                        this.ws.close();
                    }
                    break;

                case 'error':
                    // Task failed
                    if (this.steps.length > 0) {
                        this.steps[this.steps.length - 1].status = 'error';
                    }
                    this.error = update.data.error;
                    this.isRunning = false;
                    if (this.ws) {
                        this.ws.close();
                    }
                    break;
            }
        },

        stopTask() {
            if (this.ws) {
                this.ws.close();
            }
            this.isRunning = false;
        }
    };
}

// Chat panel component
function chatPanel() {
    return {
        showChat: true,
        messages: [],
        inputMessage: '',
        isLoading: false,
        error: null,
        taskId: null,

        init() {
            // Get task ID from the page (will be set by parent template)
            this.taskId = this.$el.dataset.taskId;

            // Load chat history if available
            this.loadChatHistory();
        },

        async loadChatHistory() {
            if (!this.taskId) return;

            try {
                const response = await fetch(`/api/tasks/${this.taskId}/chat`);
                if (response.ok) {
                    const data = await response.json();
                    this.messages = data.messages || [];
                    this.$nextTick(() => this.scrollToBottom());
                }
            } catch (e) {
                console.error('Failed to load chat history:', e);
            }
        },

        async sendMessage() {
            if (!this.inputMessage.trim() || this.isLoading || !this.taskId) return;

            const userMessage = this.inputMessage.trim();
            this.inputMessage = '';
            this.error = null;

            // Add user message to UI
            this.messages.push({
                id: Date.now(),
                role: 'user',
                content: userMessage,
                timestamp: new Date().toISOString()
            });

            this.$nextTick(() => this.scrollToBottom());
            this.isLoading = true;

            try {
                const response = await fetch(`/api/tasks/${this.taskId}/chat`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        message: userMessage
                    })
                });

                if (!response.ok) {
                    throw new Error(`Failed to send message: ${response.statusText}`);
                }

                const data = await response.json();

                // Add assistant response to UI
                this.messages.push({
                    id: Date.now() + 1,
                    role: 'assistant',
                    content: data.response,
                    timestamp: new Date().toISOString()
                });

                this.$nextTick(() => this.scrollToBottom());
            } catch (e) {
                console.error('Error sending message:', e);
                this.error = e.message || 'Failed to send message. Please try again.';
            } finally {
                this.isLoading = false;
            }
        },

        toggleChat() {
            this.showChat = !this.showChat;
        },

        scrollToBottom() {
            const container = this.$refs.messagesContainer;
            if (container) {
                container.scrollTop = container.scrollHeight;
            }
        },

        formatTime(timestamp) {
            const date = new Date(timestamp);
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);

            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffMins < 1440) return `${Math.floor(diffMins / 60)}h ago`;
            return date.toLocaleString();
        }
    };
}
</script>
{% endblock %}
